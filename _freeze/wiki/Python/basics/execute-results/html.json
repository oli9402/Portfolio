{
  "hash": "7e42bb3ad34681066cceb62164368df8",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: 'Learning the Basics'\ncode-fold: false\n\n---\n\n## Pycharm \n\nUse `# %% Test `to create executable blocks\n\n## Namespace\n\n- *built-in*: all objects provided by python\n- *global*: programmer defined objects across whole script\n- *local*: programmer defined objects in function blocks\n\nObject name must only be unique **within a given namespace**:\n\n::: {#eca7003d .cell execution_count=1}\n``` {.python .cell-code}\ndef my_function(x):\n  return x+10\n\ndef test_function(x):\n  def my_function(y):  # my_function: this is possible since different namespace \n    return y + 20\n  x = my_function(2)\n  return x \n\ntest_function()(y=10)\n```\n:::\n\n\nInside a function you can access a global object via the keyword `global`. You can also increase a global var inside a function for example. But this should be avoided global access.\n\nThe keyword `nonlocal` will access a variable in the next higher namespace. \n\n## Scope \n\nScope of an object refers to the code section from which an object is accessible.\n\n\n## Indexing\n\nLast index is not included:\n\n::: {#89df2cfd .cell execution_count=2}\n``` {.python .cell-code}\na = [1,2,3,4,5]\n\n# Full list\na[:5]\n\na[-1:] #equal to a[-1:5]\n\na[-1:1:-1] #2 is index 2 but not included\n\n#full list in reverse\na[-1::-1]   #equal to a[::-1]\na[:-2] #-2 is index of 4 but not included\n\na[:-2:-1]\n\n# Print last string of language\nL = [\"Mojo\", \"is\", \"a\", \"language\"]\nprint(L[3][-1:])\n\n# Print up to last string in last element\nL = [\"Mojo\", \"is\", \"a\", \"language\"]\nprint(L[3][:-1])\n```\n:::\n\n\n2D Lists return first line\n\n::: {#f339b3ea .cell execution_count=3}\n``` {.python .cell-code}\ndata = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n[row[0] for row in data]\n```\n:::\n\n\nModify index \n\n::: {#ba980d70 .cell execution_count=4}\n``` {.python .cell-code}\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]\nnumbers[1:4] = [10, 20, 30]\n```\n:::\n\n\nFor loops\n\n::: {#e48f52ce .cell execution_count=5}\n``` {.python .cell-code}\nnumbers = [12, 32, 34, 4,25, 6, 72, 8, 19] #9 elements\n\nlen(numbers) #returns 9\nprint('')\n\ni = range(6) #returns 0-5\nfor idx in i: \n  print(idx, end= ' ')\n  \nprint('\\n')\ni = range(len(numbers)) #0-8 -> 9 elements\nfor idx in i: \n  print(idx, end= ' ')\n\nprint('\\n')\ni = range(1,len(numbers)) #1-8 -> 8 elements\nfor idx in i: \n  print(idx, end= ' ')\n```\n:::\n\n\nEnumerate returns index and value\n\n::: {#ce49c42d .cell execution_count=6}\n``` {.python .cell-code}\nnumbers = [12, 32, 34, 4,25, 6, 72, 8, 19] #9 elements\n\nfor i in enumerate(numbers):\n  print(i, end = ', ')\n  print(i[0], end = ', ')\n  print(i[1])\n\nprint('----')\n# we can also save both values individuel\nfor idx, value in enumerate(numbers):\n  print(idx , value)\n```\n:::\n\n\nUsing `range(start, stop, step)` in for loop we can reverse the steps with -1. \n\n::: {#9947d140 .cell execution_count=7}\n``` {.python .cell-code}\nfor i in range(5,0,-1):\n  print(i)\n```\n:::\n\n\n## Functions\n\nFunctions can only return one reference to a storage location. So returning multiple references must be saved in a list:\n\n::: {#d9155171 .cell execution_count=8}\n``` {.python .cell-code}\ndef function(a,b):\n  return list(a,b)\n\n```\n:::\n\n\nLearning material for python functions (e.g., str.split()): [here](https://github.com/TheAlgorithms/Python/blob/master/strings/split.py) \n\n\n### Function chaining:\n\n::: {#717023b9 .cell execution_count=9}\n``` {.python .cell-code}\nfunction_1(function_2(a)) = function_2(a).function_1()\n```\n:::\n\n\n### Function Arguments\n\n::: {#4aa580d8 .cell execution_count=10}\n``` {.python .cell-code}\na,b,c = 3,4,5\n\na,b,c = 3,4,5,6 ## Error\n\na,b,*c = 3,4,5,6 # Works: assign all remaining var to c\n```\n:::\n\n\n`*` packs elements into a list. Use `*` again to unpack:\n\n::: {#b283f6ce .cell execution_count=11}\n``` {.python .cell-code}\nprint(a,b,*c)\n```\n:::\n\n\nThis can be done in function parameter aswell: \n\n::: {#5e9dee5b .cell execution_count=12}\n``` {.python .cell-code}\ndic = {'a':1, 'b':3}\ndef my_f(a,b):\n    return a+b\n\nmy_f(**dic) #Returns  4\n```\n:::\n\n\n`**` unpacks a dictionary. can only be used as parameter input?\n\nUsing `*args` in as parameter must be then accessed with a for loop, since  it is provided to the function as tupple. \n\n::: {#c25078b2 .cell execution_count=13}\n``` {.python .cell-code}\n# print first n letters of words\n\ndef strcut(*str, n):\n    for i in str:\n        print(i[:n])\n# or \n\ndef strcut(*str,n):\n    print('\\n'.join(i[:n] for i in str))\n```\n:::\n\n\n### Else after Function\n\nElse is executed after the for loop is over (more specific after the StopIteration is raised by the iterator) but if we use break (the loop doesn't come to and end: else is not executed.) The else keyword in try-except works similar but if try reaches it's end.  \n\nIf for example we search a list for a flag item we can use else for the case that the flag item is not in the list.\n\n::: {#d61eb491 .cell execution_count=14}\n``` {.python .cell-code}\nmylist = [1,2,3,4]\ntheflag = 5\n\ndef process(i):\n    return i + 0.5\n\nfor i in mylist:\n    if i == theflag:\n        break\n    process(i)\nelse:\n    raise ValueError(\"List argument missing terminal flag.\")\n```\n:::\n\n\n### Recursion\n\nSimple recursion of factorial()\n\n::: {#8f8a3635 .cell execution_count=15}\n``` {.python .cell-code}\ndef fac(n):\n  if n == 1:\n    return 1\n  else: \n    return n * fac(n-1)\n```\n:::\n\n\n### String split function\n\n::: {#55fd16af .cell execution_count=16}\n``` {.python .cell-code}\ndef split(string, delimiter):\n  \n  result_list = []\n  \n  start = 0\n  for index, char in enumerate(string):\n      if char == delimiter:\n          result_list.append(string[start:index])\n          start = index + 1\n  if start == 0:\n      return [string]\n  result_list.append(string[start:index + 1])\n    \n  return result_list\n```\n:::\n\n\n### String join function\n\ntakes an iterable (list, tuple) and concatenates its elements into a single string. The seperator is provided as string from which join is called\n\n::: {#3f31bdf8 .cell execution_count=17}\n``` {.python .cell-code}\nl = ['1','2','3']\nprint('#'.join(l))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1#2#3\n```\n:::\n:::\n\n\nIf int in list:\n\n::: {#4c2da1be .cell execution_count=18}\n``` {.python .cell-code}\nl = [1,2,3]\nprint('#'.join(map(str,l)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1#2#3\n```\n:::\n:::\n\n\n### *args and **kwargs\n\nThey allow you to write functions that can accept an arbitrary number of arguments, making your code more flexible.\n\n*args collects arguments into a tuple:\n\n::: {#0a142794 .cell execution_count=19}\n``` {.python .cell-code}\ndef print_numbers(*args):\n    for number in args:\n        print(number)\n\nprint_numbers(1, 2, 3, 4)\n```\n:::\n\n\n**kwargs collects arguments into a dictionary\n\n::: {#e76c7077 .cell execution_count=20}\n``` {.python .cell-code}\ndef print_student_info(**kwargs):\n    for key, value in kwargs.items():\n        print(f\"{key}: {value}\")\n\nprint_student_info(name=\"Alice\", age=20, grade=\"A\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nname: Alice\nage: 20\ngrade: A\n```\n:::\n:::\n\n\nCombining both args and kwargs \n\n::: {#870b3d91 .cell execution_count=21}\n``` {.python .cell-code}\ndef print_info(name, *args, **kwargs):\n    print(f\"Name: {name}\")\n    print(\"Additional info:\", args)\n    print(\"Details:\", kwargs)\n\nprint_info(\"Alice\", 25, \"Engineer\", country=\"USA\", city=\"New York\")\n```\n:::\n\n\n## List\n\nAppend new element to list \n\n::: {#bee792c2 .cell execution_count=22}\n``` {.python .cell-code}\nli = [1,2,2,3]\n\nli.append(4) \nli += [4]\n\n[2] + [1] ## -> [2,1]\n```\n:::\n\n\n## Non-Sequence Types \n\nIn Python, non-sequence types are objects that do not store elements in a specific order and do not support indexing or slicing.\n\n- Set, Dictionary, Numbers(int,float, complex), bool, None\n\n## Dictionnary \n\n::: {#f9428269 .cell execution_count=23}\n``` {.python .cell-code}\ninfo = {\"name\": \"Alice\", \"age\": 30}\nfor key in info:\n    print(key)  # Output: name, age\n\n# Iterating over keys and values\nfor key, value in info.items():\n    print(key, value)  # Output: name Alice, age 30\n```\n:::\n\n\n### Exam exercise\n\n::: {#24393c25 .cell execution_count=24}\n``` {.python .cell-code}\n# Example list\nmy_list = [10, 20, 30, 40, 50]\n\n# Initialize an empty dictionary\nmydict = {}\n\n# Iterate over the list using enumerate\nfor index, value in enumerate(my_list):\n    # Add the index and value to the dictionary\n    mydict[index] = value\n\n# Print the dictionary to verify the result\nprint(mydict)\n```\n:::\n\n\n#### Dict comprehension\n\n::: {#7b1f7c4b .cell execution_count=25}\n``` {.python .cell-code}\n# Create the dictionary using dictionary comprehension\nmydict = {index: value for index, value in enumerate(my_list)}\n```\n:::\n\n\n### exercise illias\n\n::: {#3525b2db .cell execution_count=26}\n``` {.python .cell-code}\nq_dict = {'idx': [],'qm':[], 'cat': []}\n\n\nfor idx, value in enumerate(q):\n    q_dict['idx'].append(idx)\n    q_dict['qm'].append(value)\n\n    # you can also use if, elif, else\n    # if value < 0.2\n    # elif value < 0.4\n    # elif < 0.6....\n    match value:\n        case value if 0.2 > value >= 0:\n            q_dict['cat'].append('bad')\n        case value if 0.4 > value >= 0.2:\n            q_dict['cat'].append('weak')\n        case value if 0.6 > value >= 0.4:\n            q_dict['cat'].append('balanced')\n        case value if 0.6 <= value < 0.8:\n            q_dict['cat'].append('good')\n        case value if 0.8 <= value <= 1:\n            q_dict['cat'].append('very good')\n\n```\n:::\n\n\n## String formating\n\nThere are multiple ways here are two: \n\n### Formatted String Literals\n\nStart with an f or F. Allows including variable names with {}. \n\nExample: right align and use 5 spaces including var1\n\n::: {#625f05bc .cell execution_count=27}\n``` {.python .cell-code}\nprint(f\"{var1:>5}\")\n```\n:::\n\n\nExample: self documentation and debugging: returns var name and what is stored\n`var1= -> var1=7`\n\n::: {#9fec4dc9 .cell execution_count=28}\n``` {.python .cell-code}\nprint(f\"{var1=}\")\n```\n:::\n\n\n### Format() Method\nString objects provides methods/functions and apply it to string object\n\nMore flexible way to string literals: {} only placeholders, must be specified in format()\n\n::: {#300253aa .cell execution_count=29}\n``` {.python .cell-code}\nvar1 ='world'\nvar2 = 7\n\nprint(\"hello {} {}\".format(var1, var2))\nprint(\"hello {1} {0}\".format(var2, var1))\n\ndict = {'num': 7, 'txt': 'world'}\nprint(\"hello {0[txt]} {0[num]}\".format(dict))\n\n```\n:::\n\n\n### C-style string format\n\n::: {#00ea815c .cell execution_count=30}\n``` {.python .cell-code}\nfirst_name = input(\"Enter your first name: \") # your input: Anna\nlast_name = input(\"Enter your last name: \") # your input: Meier\nbirth_year = input(\"Enter your birth year: \") # your input: 1998\nusername = \"%s%s%s\" % (first_name[0].lower(), last_name[:3].lower(), birth_year[-2:])\nprint(\"Generated username: %s\" % username)\n\n#output: Generated username: amei98\n```\n:::\n\n\n### test whether letter of string is digit or str:\n\nUse `string.isdigit()` and `string.isalpha()`\n\n- '.', '(space)' or ',' are not seen as letters\n\n::: {#f4a36716 .cell execution_count=31}\n``` {.python .cell-code}\nstring = 'Python 3.2'\n\ncnt_digits = 0\ncnt_str = 0\n\nfor s in string:\n  if s.isdigit():\n    cnt_digits += 1 \n  elif s.isalpha():\n    cnt_str + = 1\n```\n:::\n\n\n## File Handling\n\n`open(file_name, mode)` creates file object in python. It opens a pipe stream of the file that must be closed again `close()`.\n\nPython provides a way to handle close with the function `with`. As soon as the block is left, the file is closed. \n\n::: {#7f926aa6 .cell execution_count=32}\n``` {.python .cell-code}\nwith open(file_name, mode) as file_object: \n  ...\n  ...\n  ...\n```\n:::\n\n\n### Read\n\n## Object Oriented Programming \n\n\nVariables are references to objects and objects belong to a class.\n\n`x = 99` is a references to storage location of a object of class int\n\n### Class\n\nBlueprint for what an object should look like and how it should function.\nHas several elements. Functions are called methods (inside a class)\n\n- header: indicates beginning of class\n- __init__(): constructor (build) for objects\n- variables: Class and object\n- self: reference to the object that is created\n- class variable:\n  -A class variable in Python is a variable that is shared among all instances of a class. It is defined *within the class but outside of any instance methods*. Class variables are commonly used when a value needs to be *consistent across all instances of a class*.\n  - In methods you can access a class variable with for example: `Customer.class_variable_name` no self. is needed.\n\n\n### Class Methods \n\n### Static Methods \n\nSame as regular function but defined in a class. Still they are rather independent of the class but are accessed with class.function. No self is needed.\n\n::: {#ecb86f8b .cell execution_count=33}\n``` {.python .cell-code}\nclass A:\n  def __init__(self):\n    ...\n    \n  @staticmethods\n  def function(str):\n    return function(str)\n  \nclass.function\n```\n:::\n\n\n### Object Methods\n\n::: {#5a2800ae .cell execution_count=34}\n``` {.python .cell-code}\nclass PackageName: \n  \"\"\"\n  Description\n  \"\"\"\n  def __init__(self, name: str, quality: str) -> none:\n      self.name = name\n      self.quality = quality\n# create an object from this class\n\nx: PackageName = PackageName(name = 'ggplot', quality = 'high') #self becomes x\n```\n:::\n\n\n{{< video https://www.youtube.com/watch?v=rLyYb7BFgQI&t=323s&ab_channel=Indently >}}\n\n\n\n### Dunder Methods \n\nHow should objects of a class behave for certain operations\n\n::: {#d70290e6 .cell execution_count=35}\n``` {.python .cell-code}\nclass A: \n  ...\n  \n  def __add__(self,other):\n    return f'{self.name} + {other.name}'\n  \n\n\nx = A()\ny = A()\n\nprint(x + y)\n```\n:::\n\n\n### Subclass\n\nInheritance creates a hierarchy of classes\n\n- Animal -> Bird and Cow\n\ntest with `issubclass(Bird, Animal)`. Child classes get all properties from parent class. \n\n#### Inheritance\n\nWe can use `super()` to refer to the upper level class (parent class in this case)\nIf we first create a class, the function of the object class if inhereted to our created object. \n\n::: {#cb1aefa8 .cell execution_count=36}\n``` {.python .cell-code}\nclass Animal(object class): \n  def __init__(self, weight):\n    self.weight = weight\n    \nclass Bird(Animal):\n  def _init__(self, weight): #override\n    super().__init__(weight)\n    # or Animal.__init__(self, weight)\n```\n:::\n\n\n#### Inheritance: Override \n\nWe don't want all methods or variables from parent class.\nThe interpreter first checks methods and objects in the subclass before it checks the parents, so we can just overwrite the objects in the subclass (or extend functionality). We have to use the same name for the method or other objects! \n\n\n### Access Modifiers \n\n- public: access through object\n- protected: only in subclass accessible\n  - create with self._name. Is used to mark internal use in class and subclass \n- private: only in declaration of own class accessible\n  - create with self.__name. Python internally renames variable. Can't be accessed in sub classes\n  \n#### Example private attribute and private method:\n\n::: {#e47706cb .cell execution_count=37}\n``` {.python .cell-code}\nclass BankAccount:\n    def __init__(self, balance):\n        self.__balance = balance  # Private attribute\n\n    def __secret_method(self):  # Private method\n        print(\"This is a secret method!\")\n\n    def get_balance(self):\n        return self.__balance  # ✅ Allowed within the class\n\n# Trying to access private members\naccount = BankAccount(1000)\n# print(account.__balance)  # ❌ AttributeError\n# account.__secret_method()  # ❌ AttributeError\n\n# Accessing private members using name mangling (not recommended)\nprint(account._BankAccount__balance)  # ✅ Works, but discouraged\naccount._BankAccount__secret_method()  # ✅ Works, but discouraged\n```\n:::\n\n\n#### Example protected attribute and protected method:\n\n::: {#12a2dbbb .cell execution_count=38}\n``` {.python .cell-code}\nclass Car:\n    def __init__(self, brand):\n        self._brand = brand  # Protected attribute\n\n    def _show_brand(self):  # Protected method\n        print(f\"Brand: {self._brand}\")\n\nclass SportsCar(Car):\n    def display(self):\n        print(f\"Sports Car Brand: {self._brand}\")  # ✅ Allowed in subclass\n\n# Accessing protected attributes and methods\nc = Car(\"Tesla\")\nprint(c._brand)  # ⚠️ Allowed but discouraged\nc._show_brand()  # ⚠️ Allowed but discouraged\n```\n:::\n\n\n## Mulitple inheritance\n\nMultiple parents. Can cause problems for the interpreter if same methods twice.\n\nSolved with Method Resolution Order (MRO): tries to find a linearization of all classes and depends on the order of inheritance. It doesn't find a feasible solution every time. Sometimes it helps to swap order. \n\n\n## Modules\n\npaths when import: \n\n- the current script sets the root for the ide but not for the terminal.\n- with `..` you can move up in the folder hierarchy. \n- instead of / or \\\\ python uses . \n- `from math import *` imports everything and you can refer to the function without `math.`\n  - not a good style since it can cause problems\n  \n## If name = main\n\nthe name of the script is only *main* if it's the root script.\n\nSo if you add: \n\n::: {#b9d735f1 .cell execution_count=39}\n``` {.python .cell-code}\nif __name__ = \"main\":\n  ...tests\n```\n:::\n\n\nyou can code functionality that only runs when the script is the root and doesn't run when the file has been imported into a different script. \n\n## Deep vs. Shallow Copy\n\nVariable stores references to an object that is stored in *one or more(string, lists, tuples..)* storage cells. So copying a variable, copies the reference:\n\n::: {#88cd4a95 .cell execution_count=40}\n``` {.python .cell-code}\nx = 99.23\ny = x # copy of reference\n\nid(x) == id(y) \n\nx = 43.12\nid(x) == id(y)\n\n# But..\na = 19.2\nb = 19.2\n\nid(a) == id(b) #two different instances of object int\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\nFalse\n```\n:::\n:::\n\n\nAssigning a new value creates a new instance of object int by calling: `b = int.__new__(value)`.\n\nLists are mutable objects: x only refers to the first element of list. \n\n::: {#6cb96679 .cell execution_count=41}\n``` {.python .cell-code}\nx = [1,2,3,4,5]\n\ny = x  #copy\ny[2] = 6 #change 3 element, doesnt' create a new object!!\n\nprint(x)\n\ny[0] = 9\nid(x) == id(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1, 2, 6, 4, 5]\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\nTrue\n```\n:::\n:::\n\n\nThis is a side effect. So we can create a real copy with the `copy()` function. Only available for mutable objects (sequences), so not for tuples.\n\n::: {#e0e81a38 .cell execution_count=42}\n``` {.python .cell-code}\nx = [1,2,3,4,5]\n\ny = x.copy()\n\nid(x) == id(y)\n\nstr_text = 'hello'\n\n#str_copy = str_text.copy() doens't work since string gernally not mutable\n```\n:::\n\n\nNested Lists = special case. `copy()` *returns a shallow copy!*:\nNested lists are references to new storage location\n\n::: {#d6173a50 .cell execution_count=43}\n``` {.python .cell-code}\nnested_list = [1,2,3,[4,5]]\n\ny = nested_list.copy()\n\ny[-1][0] = 99\n\nprint(y)\nprint(f'not desired change: {nested_list=}')\n\nprint(f'{id(y) == id(nested_list)=}')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1, 2, 3, [99, 5]]\nnot desired change: nested_list=[1, 2, 3, [99, 5]]\nid(y) == id(nested_list)=False\n```\n:::\n:::\n\n\n::: {#990bc130 .cell execution_count=44}\n``` {.python .cell-code}\n#import copy\nnested_list = [1,2,3,[4,5]]\n\n#y = nested_list.copy.deepcopy(nested_list)\ny[-1][0] = 99\n\nprint(f'didn\\'t change: {nested_list=}')\n```\n:::\n\n\n## Lambda Function\n\nKeep in mind:\n\n::: {#76922919 .cell execution_count=45}\n``` {.python .cell-code}\ndef my_fun():\n  def inner_fun(x):\n    return x \n  return inner_fun\n\nmy_if = my_fun() #reference to inner function\nprint(my_if('hello'))\n\n#is the same as \n\nmy_if = my_fun #reference to outer function\nprint(my_if()('hello'))\n```\n:::\n\n\nLambda: No header. Only body of function. Only one expression.\n\n::: {#5c4f3cdd .cell execution_count=46}\n``` {.python .cell-code}\nx = lambda a,b: a + b\n\nprint('x: ', x(3,5))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nx:  8\n```\n:::\n:::\n\n\n::: {#11c266e3 .cell execution_count=47}\n``` {.python .cell-code}\ndef fun():\n  return 'hello' \n  \nx = lambda: fun()\n\nprint('x: ', x())\n\nx = lambda a: a()\nprint('x: ', x(fun))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nx:  hello\nx:  hello\n```\n:::\n:::\n\n\nWe can use lambda for generic methods example: \n\n::: {#fc0423b3 .cell execution_count=48}\n``` {.python .cell-code}\ndef fun_ii(f, a, b):\n  return f(a,b)\n\nprint('fun_ii: ' , fun_ii(lambda x,y: x + y, 2, 3))\nprint('fun_ii: ' , fun_ii(lambda x,y: x - y, 2, 3))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfun_ii:  5\nfun_ii:  -1\n```\n:::\n:::\n\n\nUsually combined with other functions like `map()` or `sort()`.\n\n`map()`: applies a function to every single item of an iterable. Same as for loop.\n\n::: {#9a72e2d9 .cell execution_count=49}\n``` {.python .cell-code}\nnumbers = [1,2,3,4]\ntest = map(lambda element: element-1,numbers) #we get a map object back\n\ntest = list(map(lambda element: element-1,numbers)) #create a list. List(test)\ntest\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```\n[0, 1, 2, 3]\n```\n:::\n:::\n\n\n`sort()`: sorts an iterable based on a given comparator\n\n::: {#d6066e8c .cell execution_count=50}\n``` {.python .cell-code}\n#sorts based on remains after modulo\nnumbers = [1,2,3,4,6]\n\nnumbers.sort(key= lambda element: element %3)\nprint(numbers)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[3, 6, 1, 4, 2]\n```\n:::\n:::\n\n\n## List Comprehension\n\nSingle expression of for loop:\n\n::: {#5a0e1342 .cell execution_count=51}\n``` {.python .cell-code}\nx = [1,2,3,4,5,6]\nprint(x)\n\nx2 =[i**2 for i in x]\nprint(x2)\n\nx = [i**2 for i in x]\nprint(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1, 2, 3, 4, 5, 6]\n[1, 4, 9, 16, 25, 36]\n[1, 4, 9, 16, 25, 36]\n```\n:::\n:::\n\n\nAdd conditions\n\n::: {#88c8eee3 .cell execution_count=52}\n``` {.python .cell-code}\nx = [1,2,3,4,5,6]\n\nx2 = [i**2 for i in x if i%2] #unequal numbers (>0 equals true)\nprint(x2)\n\nx3 = [i**2 for i in x if not i%2] #equal numbers !(>0 equals true)\nprint(x3)\n\nx4 = [i**2 if not i%2 else i-10 for i in x] #if else short-hand\nprint(x4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1, 9, 25]\n[4, 16, 36]\n[-9, 4, -7, 16, -5, 36]\n```\n:::\n:::\n\n\nNested Looops\n\n::: {#244240ed .cell execution_count=53}\n``` {.python .cell-code}\nli = [[1,2,3],[22,33]]\n\nres = [element*2 for row in li for element in row] #simple list return\nres2 = [[element*2 for element in row] for row in li] #nested list return\nprint(res)\nprint('\\n')\nprint(res2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[2, 4, 6, 44, 66]\n\n\n[[2, 4, 6], [44, 66]]\n```\n:::\n:::\n\n\nComprehension with tuples returns a generator but you can use unpacker `*`. \n\n::: {#91122961 .cell execution_count=54}\n``` {.python .cell-code}\nword_list = [\"apple\", \"banana\", \"cherry\", \"date\"]\n\n# Use list comprehension to add \"__\" to every entry\nmodified_list = [word + \"__\" for word in word_list]\n```\n:::\n\n\n## Dictionairy comprehension\n\n`zip()` returns list of tuples\n\n::: {#ca76cf47 .cell execution_count=55}\n``` {.python .cell-code}\n#turn into dict\nx = [1,2,4,5]\n\nd = {i:i for i in x}\nprint(d)\nd1 = {k:v for (k,v) in enumerate(x)}\nprint(d1)\n\nd2 = {k:v for (k,v) in zip(['a','b','c'],x)}\nprint(d2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{1: 1, 2: 2, 4: 4, 5: 5}\n{0: 1, 1: 2, 2: 4, 3: 5}\n{'a': 1, 'b': 2, 'c': 4}\n```\n:::\n:::\n\n\n::: {#25f88441 .cell execution_count=56}\n``` {.python .cell-code}\nfrom random import sample\n\nclass Stream:\n    def __init__(self, id):\n        self.my_id = id\n    \n    def __repr__(self):\n        return f\"Stream obj: {self.my_id}\"\n\n# Create 10 stream objects with random IDs (e.g., from 1 to 100)\nstream_objects = [Stream(id) for id in sample(range(1, 101), 10)]\n\n# Print each stream object using unpack operator \nprint(*stream_objects, sep='\\n')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nStream obj: 40\nStream obj: 7\nStream obj: 91\nStream obj: 11\nStream obj: 71\nStream obj: 82\nStream obj: 39\nStream obj: 15\nStream obj: 45\nStream obj: 73\n```\n:::\n:::\n\n\n## Try-Except\n\nStrict order:\n\n- try:\n- except: (optional if there is finally)\n- else: (optional, *executed only if no exception is raised.*)\n- finally: (optional if there is except, is executed always no matter what)\n  - finally still breaks code if there is an error so everything after finally is not executed (if no exception is given).\n  - finally is good for garbarge collection: delete used variable in try, close files etc. or to give message why something went wrong\n\n::: {#53643033 .cell execution_count=57}\n``` {.python .cell-code}\ntry:\n  num = input('Enter a number: ')\n  frac = 1/int(num)\nexcept ValueError as e:\n  print('no number given:', e)\nexcept ZeroDivisionError:\n  print('can not divide by 0')\nexcept:\n  print('any other error happend')\nelse:\n  print(f'the fraction is: {frac}')\nfinally:\n  print('leaving try-except clause')\n```\n:::\n\n\nExceptions are handled in order and once one is executed the reset is skipt including else statement.\nFor example the second ZeroDivisionError will not be executed.\n\n::: {#09a71944 .cell execution_count=58}\n``` {.python .cell-code}\ntry:\n  num = input('Enter a number: ')\n  frac = 1/int(num)\nexcept (ValueError,ZeroDivisionError) as e:\n  print('no number given:', e)\nexcept ZeroDivisionError:\n  print('can not divide by 0')\nexcept:\n  print('any other error happend')\nelse:\n  print(f'the fraction is: {frac}')\nfinally:\n  print('leaving try-except clause')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nany other error happend\nleaving try-except clause\n```\n:::\n:::\n\n\nThese examples are explicit Exceptions since we specifiy the excat error. If we use `except Exception as e` then this is implicit.\n\n::: {#72d217d0 .cell execution_count=59}\n``` {.python .cell-code}\ndef strselect(string,key,p):\n    return_list = []\n    for i in string:\n        try:    \n            if i[p] == key:\n                return_list.append(i)\n        except IndexError as e:\n            print(\"string index out of range\")\n    return return_list\n\n\n#possible function call:\nprint(strselect([\"hello\", \"of\", \"help\", \"world\"], key = \"l\", p = 2))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nstring index out of range\n['hello', 'help']\n```\n:::\n:::\n\n\n### Customize and Raise Errors\n\nUsing the keyword `raise` we can raise an error:\n\nIf creating an own CustError class don't inheritage from BaseException.\n\n::: {#bab73b23 .cell execution_count=60}\n``` {.python .cell-code}\nclass CustError(Exception):\n  def __init__(self,message):\n    super().__init__(message)\n    \n    # customize error code..\n    self.errors = \"custom error\"\n\nif input('enter number: ') == '0': \n  raise CustError('customized error message')\n\ndef invert_value(val):\n  if type(val) != int:\n    raise ValueError('the given value is not of type integer.')\n  \n  return 1/val\n\ntry: \n  invert_value(19.2)\nexcept ValueError as e:\n  print(e)\n  \n  #returns our custome message\n```\n:::\n\n\n## Generator\n\n*Iterable*\n\nObjects that implements the `__iter__()` method and returns an iterator \nExamples: lists,tuples, sets, strings\n\n::: {#0fe02428 .cell execution_count=61}\n``` {.python .cell-code}\n# Iterable object (list)\nmy_list = [1, 2, 3]\n\n# Create an iterator from the iterable\nmy_iterator = iter(my_list)\n\n# Checking if the iterator is an iterable\nprint(isinstance(my_iterator, Iterable))  # True (because an iterator is iterable)\n\n# Iterating through the iterator\nprint(next(my_iterator))  # Output: 1\nprint(next(my_iterator))  # Output: 2\nprint(next(my_iterator))  # Output: 3\n\n# The following call will raise StopIteration as all items are exhausted\n# print(next(my_iterator))  # StopIteration\n```\n:::\n\n\n*Iterator: *\n\nIn `for i in li:` the keyword `for` creates an iterator and passes the provided list (iterable). The iterator points to the first element of the list and the object is returned. The we call the `__next__()` method of this object to get the second object in li until `__next__()` raises an *StopIteration* exception. An iterator is always an iterable but not all iterables are iterators\n\n- str, lists, tuples, sets, dictionaries, ranges, files, generators\n\n::: {#c10bb092 .cell execution_count=62}\n``` {.python .cell-code}\nx = list(range(9))\n\n\nitr = iter(x)\n\nitr.__next__()\nitr.__next__()\nprint('-'*10)\n# Iterator remembers current position so for loop will only print remaining i's\nfor i in itr: \n  print(i)\n\n# raises error\n#itr.__next__()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n----------\n2\n3\n4\n5\n6\n7\n8\n```\n:::\n:::\n\n\n::: {#beb92b42 .cell execution_count=63}\n``` {.python .cell-code}\n# A generator expression\ngen_expr = (x * 2 for x in range(5))\n\nnext(gen_expr)\n```\n:::\n\n\n### non-Iterable\n\na non-iterable object is an object that cannot be looped over:\n\n- int, float, bool, complex, none\n\n\n### Concept of Generator (Generator Function)\n\nEach iteration is called on demand and not at the start: saving memory (lazy evaluation)\n\n- Uses yield keyword instead of return and returns a generator iterator. \n- Breaks at each yield but remembers where it was and can be continuied until StopIterator is raised\n- can be written as generator expression without yield: `(x**2 for x in range(4))` \n- \n\n::: {#a5e502f7 .cell execution_count=64}\n``` {.python .cell-code}\ndef my_sum(x):\n  \n  return x + 2\n\ndef my_sum_gen(x):\n  \n  y = x \n  while True:\n    \n    yield y + 2 \n    yield y + 5\n    \n\nr2 = my_sum_gen(7)\n\nprint(next(r2))\nprint(next(r2))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n9\n12\n```\n:::\n:::\n\n\nExample\n\n\"In ordered large list are there values smaller than 0?\"\n\n::: {#4b47c281 .cell execution_count=65}\n``` {.python .cell-code}\nk = range(1_000_000)\nany(x < 0 for x in k)\n```\n\n::: {.cell-output .cell-output-display execution_count=22}\n```\nFalse\n```\n:::\n:::\n\n\n::: {#2a07cc80 .cell execution_count=66}\n``` {.python .cell-code}\n# A generator function\ndef my_generator():\n    yield 1\n    yield 2\n    yield 3\n\n# Create a generator object\ngen = my_generator()\n\n# Using the generator object in a for loop (iteration)\nfor value in gen:\n    print(value)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1\n2\n3\n```\n:::\n:::\n\n\n# Exercise Test\n\n## Largest number: delete if in last position\n\n::: {#1d4fb578 .cell execution_count=67}\n``` {.python .cell-code}\nfor i in numbers[:-1]: #go through numbers except last \n    if i == max(numbers):\n        break #exit loop: max number not last position\nelse: #is executed only if for loop comes to end\n    numbers.pop() #removes last number\n```\n:::\n\n\n## OOP Buildings\n\n::: {#2516364e .cell execution_count=68}\n``` {.python .cell-code}\nclass Building:\n    # Class variables\n    _counter = 0\n    _id_container = []\n\n    def __init__(self, number_of_floors):\n        # Object variables\n        self._number_of_floors = number_of_floors\n        self._building_id = self._get_new_id()  # Assign building id at creation\n\n    def _get_new_id(self):\n        # Increment counter and create a new building ID\n        Building._counter += 1\n        building_id = Building._counter\n        if building_id in Building._id_container:\n            raise ValueError(f\"Building ID {building_id} is already taken.\")\n        Building._id_container.append(building_id)\n        return building_id\n\n    def get_number_of_floors(self):\n        # Return the number of floors for the building\n        return self._number_of_floors\n\nclass OfficeBuilding(Building):\n    def __init__(self, number_of_floors, number_of_working_places):\n        # Call parent class constructor to initialize number_of_floors and building_id\n        super().__init__(number_of_floors)\n        # Additional object variable for office buildings\n        self._number_of_working_places = number_of_working_places\n\n    def get_number_of_working_places(self):\n        # Return the number of working places for the office building\n        return self._number_of_working_places\n\n# Create a Building object with 10 floors\nbuilding_1 = Building(10)\n# Create an OfficeBuilding object with 15 floors and 200 working places\noffice_building_1 = OfficeBuilding(15, 200)\n\n# Print building IDs and number of floors for both buildings\nprint(f\"Building 1 ID: {building_1._building_id}, Floors: {building_1.get_number_of_floors()}\")\nprint(f\"Office Building 1 ID: {office_building_1._building_id}, Floors: {office_building_1.get_number_of_floors()}, Working Places: {office_building_1.get_number_of_working_places()}\")\n```\n:::\n\n\n## Lambda Divisor 3 \n\n::: {#2afc6d52 .cell execution_count=69}\n``` {.python .cell-code}\n# Define the lambda function using conditional expression\ndivisible_by_3 = lambda num: True if num % 3 == 0 else False\n\n# Example list (even_list)\neven_list = [2, 3, 6, 8, 9, 12, 15, 20, 21, 24]\n\n# Use the lambda function to filter the numbers divisible by 3\ndivisible_by_3_list = [num for num in even_list if divisible_by_3(num)]\n\n# Print the resulting list\nprint(divisible_by_3_list)\n```\n:::\n\n\n## Lambda dict\n\n::: {#59a11726 .cell execution_count=70}\n``` {.python .cell-code}\n# Example list\neven_list = [2, 3, 6, 8, 9, 12, 15, 20, 21, 24]\n\n# Create dictionary using lambda function and dictionary comprehension\ndivisible_dict = {num: (lambda x: True if 98729 % x == 0 else False)(num) for num in even_list}\n\n# Print the resulting dictionary\nprint(divisible_dict)\n```\n:::\n\n\n## Customer\n\n::: {#1a826ba5 .cell execution_count=71}\n``` {.python .cell-code}\n#!/usr/bin/ python\n\nclass Customer():\n\n    custType = 'standard'\n    custNo = 0\n\n    def __init__(self, first_name, last_name, company_name):\n        self.f_name = first_name\n        self.l_name = last_name\n        self.c_name = company_name\n        self.custNo = None                      # customer number\n        self.dist2hub = None                    # distance to storage hub\n        self.avgDelPerYear = None               # average no of deliveries per year\n        self.recCargoWeight = None              # recording (list) of delivery weights\n\n    def load_cust_data(self):\n        '''\n        The method 'load_cust_data()' initializes instance variables that are\n        initialized with none. These numbers have no effect on the program\n        extension, i.e. are irrelevant for the evaluation.\n        '''\n        self.custNo = Customer.custNo\n        self.dist2hub = (self.custNo+15)*15\n        self.avgDelPerYear = 1/self.dist2hub*2250\n        self.recCargoWeight = list(range(self.custNo))\n        Customer.custNo += 1                    # increment customer number\n\n    def correctCargoWeights(self,correction):\n        '''\n        For cargoWeight correction, the passed lambda function from the parameter\n        list is applied on all elements of the cargoWeight instance variable\n        (i.e. the parameter correction points to a lambda function).\n        '''\n        self.recCargoWeight = list(map(correction, self.recCargoWeight))\n```\n:::\n\n\n### Example of Use\n\n::: {#9a2cdb2c .cell execution_count=72}\n``` {.python .cell-code}\n# Create a new Customer object\ncustomer1 = Customer(\"John\", \"Doe\", \"ABC Corp\")\n\n# Load customer data\ncustomer1.load_cust_data()\n\n# Print customer details\nprint(f\"Customer {customer1.f_name} {customer1.l_name} has ID {customer1.custNo}\")\nprint(f\"Distance to Hub: {customer1.dist2hub}\")\nprint(f\"Average Deliveries per Year: {customer1.avgDelPerYear}\")\nprint(f\"Cargo Weights: {customer1.recCargoWeight}\")\n\n# Correct cargo weights using a lambda function (e.g., multiplying each by 2)\ncustomer1.correctCargoWeights(lambda x: x * 2)\n\n# Print corrected cargo weights\nprint(f\"Corrected Cargo Weights: {customer1.recCargoWeight}\")\n\n```\n:::\n\n\nCustomer John Doe has ID 0\nDistance to Hub: 225\nAverage Deliveries per Year: 10.0\nCargo Weights: [0]\nCorrected Cargo Weights: [0]\n\n\n### SportCustomer in different file\n\n::: {#75de6854 .cell execution_count=73}\n``` {.python .cell-code}\n# Assuming that SportCustomer class should inherit from Customer (or any base class)\nfrom customer import Customer\n\nclass SportCustomer(Customer):\n    def __init__(self, first_name, last_name, company_name):\n        # Initialize the parent class (Customer)\n        super().__init__(first_name, last_name, company_name)\n        self.priority = None  # Initialize the priority instance variable\n\n    def setPriority(self, priority):\n        \"\"\"\n        Sets the 'priority' instance variable.\n        Raises a ValueError if the passed priority is greater than 100.\n        \"\"\"\n        if priority > 100:\n            raise ValueError(\"Priority value cannot be greater than 100\")\n        self.priority = priority\n\n```\n:::\n\n\n",
    "supporting": [
      "basics_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}