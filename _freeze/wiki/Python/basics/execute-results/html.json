{
  "hash": "df2bdf7abd3d6c64a8f80cdfca13c3d6",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: 'Learning the Basics'\ncode-fold: false\n---\n\n## Namespace\n\n- *built-in*: all objects provided by python\n- *global*: programmer defined objects across whole script\n- *local*: programmer defined objects in function blocks\n\nObject name must only be unique **within a given namespace**:\n\n::: {#9aa78db9 .cell execution_count=1}\n``` {.python .cell-code}\ndef my_function(x):\n  return x+10\n\ndef test_function(x):\n  def my_function(y):  # my_function: this is possible since different namespace \n    return y + 20\n  x = my_function(2)\n  return x \n\ntest_function()(y=10)\n```\n:::\n\n\nInside a function you can access a global object via the keyword `global`. You can also increase a global var inside a function for example. But this should be avoided global access.\n\nThe keyword `nonlocal` will access a variable in the next higher namespace. \n\n## Scope \nScope of an object refers to the code section from which an object is accessible.\n***\n\n## Indexing\n\nLast index is not included:\n\n::: {#8b0aae13 .cell execution_count=2}\n``` {.python .cell-code}\na = [1,2,3,4,5]\n\n# Full list\na[:5]\n\na[-1:] #equal to a[-1:5]\n\na[-1:1:-1] #2 is index 2 but not included\n\n#full list in reverse\na[-1::-1]   #equal to a[::-1]\na[:-2] #-2 is index of 4 but not included\n\na[:-2:-1]\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n[5]\n```\n:::\n:::\n\n\n2D Lists return first line\n\n::: {#d4d53cd5 .cell execution_count=3}\n``` {.python .cell-code}\ndata = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n[row[0] for row in data]\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\n[1, 4, 7]\n```\n:::\n:::\n\n\nModify index \n\n::: {#83015d44 .cell execution_count=4}\n``` {.python .cell-code}\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]\nnumbers[1:4] = [10, 20, 30]\n```\n:::\n\n\nFor loops\n\n::: {#14108d15 .cell execution_count=5}\n``` {.python .cell-code}\nnumbers = [12, 32, 34, 4,25, 6, 72, 8, 19] #9 elements\n\nlen(numbers) #returns 9\nprint('')\n\ni = range(6) #returns 0-5\nfor idx in i: \n  print(idx, end= ' ')\n  \nprint('\\n')\ni = range(len(numbers)) #0-8 -> 9 elements\nfor idx in i: \n  print(idx, end= ' ')\n\nprint('\\n')\ni = range(1,len(numbers)) #1-8 -> 8 elements\nfor idx in i: \n  print(idx, end= ' ')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n0 1 2 3 4 5 \n\n0 1 2 3 4 5 6 7 8 \n\n1 2 3 4 5 6 7 8 \n```\n:::\n:::\n\n\nEnumerate returns index and value\n\n::: {#3ce0c67a .cell execution_count=6}\n``` {.python .cell-code}\nnumbers = [12, 32, 34, 4,25, 6, 72, 8, 19] #9 elements\n\nfor i in enumerate(numbers):\n  print(i, end = ', ')\n  print(i[0], end = ', ')\n  print(i[1])\n\nprint('----')\n# we can also save both values individuel\nfor idx, value in enumerate(numbers):\n  print(idx , value)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(0, 12), 0, 12\n(1, 32), 1, 32\n(2, 34), 2, 34\n(3, 4), 3, 4\n(4, 25), 4, 25\n(5, 6), 5, 6\n(6, 72), 6, 72\n(7, 8), 7, 8\n(8, 19), 8, 19\n----\n0 12\n1 32\n2 34\n3 4\n4 25\n5 6\n6 72\n7 8\n8 19\n```\n:::\n:::\n\n\n----\n## Functions\n\nFunctions can only return one reference to a storage location. So returning multiple references must be saved in a list:\n\n::: {#a0b4e705 .cell execution_count=7}\n``` {.python .cell-code}\ndef function(a,b):\n  return list(a,b)\n\n```\n:::\n\n\nLearning material for python functions (e.g., str.split()): [here](https://github.com/TheAlgorithms/Python/blob/master/strings/split.py) \n\n\n### Function chaining:\n\n::: {#b945d12f .cell execution_count=8}\n``` {.python .cell-code}\nfunction_1(function_2(a)) = function_2(a).function_1()\n```\n:::\n\n\n### Function Arguments\n\n::: {#ccb9f9e8 .cell execution_count=9}\n``` {.python .cell-code}\na,b,c = 3,4,5\n\na,b,c = 3,4,5,6 ## Error\n\na,b,*c = 3,4,5,6 # Works: assign all remaining var to c\n```\n:::\n\n\n`*` packs elements into a list. Use `*` again to unpack:\n\n::: {#537ce18d .cell execution_count=10}\n``` {.python .cell-code}\nprint(a,b,*c)\n```\n:::\n\n\nThis can be done in function parameter aswell: \n\n::: {#08e5520e .cell execution_count=11}\n``` {.python .cell-code}\ndic = {'a':1, 'b':3}\ndef my_f(a,b):\n    return a+b\n\nmy_f(**dic) #Returns  4\n```\n:::\n\n\n`**` unpacks a dictionary. can only be used as parameter input?\n\nUsing `*args` in as parameter must be then accessed with a for loop, since  it is provided to the function as tupple. \n\n::: {#a918e05d .cell execution_count=12}\n``` {.python .cell-code}\n# print first n letters of words\n\ndef strcut(*str, n):\n    for i in str:\n        print(i[:n])\n# or \n\ndef strcut(*str,n):\n    print('\\n'.join(i[:n] for i in str))\n```\n:::\n\n\n### Else after Function\n\nIf for example we search a list for a flag item we can use else for the case that the flag item is not in the list.\n\n::: {#d1aac318 .cell execution_count=13}\n``` {.python .cell-code}\nfor i in mylist:\n    if i == theflag:\n        break\n    process(i)\nelse:\n    raise ValueError(\"List argument missing terminal flag.\")\n```\n:::\n\n\n### Recursion\n\nSimple recursion of factorial()\n\n::: {#548c1c3e .cell execution_count=14}\n``` {.python .cell-code}\ndef fac(n):\n  if n == 1:\n    return 1\n  else: \n    return n * fac(n-1)\n```\n:::\n\n\n***\n\n## List\n\nAppend new element to list \n\n::: {#db5310bd .cell execution_count=15}\n``` {.python .cell-code}\nli = [1,2,2,3]\n\nli.append(4) \nli += [4]\n\n[2] + [1] ## -> [2,1]\n```\n:::\n\n\n***\n\n## String formating\nThere are multiple ways here are two: \n\n### Formatted String Literals\nStart with an f or F. Allows including variable names with {}. \n\nExample: right align and use 5 spaces including var1\n\n::: {#ebfcb339 .cell execution_count=16}\n``` {.python .cell-code}\nprint(f\"{var1:>5}\")\n```\n:::\n\n\nExample: self documentation and debugging: returns var name and what is stored\n`var1= -> var1=7`\n\n::: {#9c37d870 .cell execution_count=17}\n``` {.python .cell-code}\nprint(f\"{var1=}\")\n```\n:::\n\n\n### Format() Method\nString objects provides methods/functions and apply it to string object\n\nMore flexible way to string literals: {} only placeholders, must be specified in format()\n\n::: {#cb9efe92 .cell execution_count=18}\n``` {.python .cell-code}\nvar1 ='world'\nvar2 = 7\n\nprint(\"hello {} {}\".format(var1, var2))\nprint(\"hello {1} {0}\".format(var2, var1))\n\ndict = {'num': 7, 'txt': 'world'}\nprint(\"hello {0[txt]} {0[num]}\".format(dict))\n\n```\n:::\n\n\n***\n\n## File Handling\n\n`open(file_name, mode)` creates file object in python. It opens a pipe stream of the file that must be closed again `close()`.\n\nPython provides a way to handle close with the function `with`. As soon as the block is left, the file is closed. \n\n::: {#5ea0b4ef .cell execution_count=19}\n``` {.python .cell-code}\nwith open(file_name, mode) as file_object: \n  ...\n  ...\n  ...\n```\n:::\n\n\n### Read\n\n## Object Oriented Programming \n\n\nVariables are references to objects and objects belong to a class.\n\n`x = 99` is a references to storage location of a object of class int\n\n### Class\nBlueprint for what an object should look like and how it should function.\nHas several elements. Functions are called methods (inside a class)\n\n- header: indicates beginning of class\n- __init__(): constructor (build) for objects\n- variables: Class and object\n- self: reference to the object that is created\n\n### Class Methods \n\n### Static Methods \nSame as regular function but defined in a class. Still they are rather independent of the class but are accessed with class.function. No self is needed.\n\n::: {#fe1ed72f .cell execution_count=20}\n``` {.python .cell-code}\nclass A:\n  def __init__(self):\n    ...\n    \n  @staticmethods\n  def function(str):\n    return function(str)\n  \nclass.function\n```\n:::\n\n\n### Object Methods\n\n::: {#eb2219d4 .cell execution_count=21}\n``` {.python .cell-code}\nclass PackageName: \n  \"\"\"\n  Description\n  \"\"\"\n  def __init__(self, name: str, quality: str) -> none:\n      self.name = name\n      self.quality = quality\n# create an object from this class\n\nx: PackageName = PackageName(name = 'ggplot', quality = 'high') #self becomes x\n```\n:::\n\n\n{{< video https://www.youtube.com/watch?v=rLyYb7BFgQI&t=323s&ab_channel=Indently >}}\n\n\n\n### Dunder Methods \n\nHow should objects of a class behave for certain operations\n\n::: {#4aa82532 .cell execution_count=22}\n``` {.python .cell-code}\nclass A: \n  ...\n  \n  def __add__(self,other):\n    return f'{self.name} + {other.name}'\n  \n\n\nx = A()\ny = A()\n\nprint(x + y)\n```\n:::\n\n\n### Subclass\n\nInheritance creates a hierarchy of classes\n\n- Animal -> Bird and Cow\n\ntest with `issubclass(Bird, Animal)`. Child classes get all properties from parent class. \n#### Inheritance\n\nWe can use `super()` to refer to the upper level class (parent class in this case)\nIf we first create a class, the function of the object class if inhereted to our created object. \n\n::: {#5d8e6be3 .cell execution_count=23}\n``` {.python .cell-code}\nclass Animal(object class): \n  def __init__(self, weight):\n    self.weight = weight\n    \nclass Bird(Animal):\n  def _init__(self, weight): #override\n    super().__init__(weight)\n    # or Animal.__init__(self, weight)\n```\n:::\n\n\n#### Inheritance: Override \n\nWe don't want all methods or variables from parent class.\nThe interpreter first checks methods and objects in the subclass before it checks the parents, so we can just overwrite the objects in the subclass (or extend functionality). We have to use the same name for the method or other objects! \n\n\n### Access Modifiers \n\n- public: access through object\n- protected: only in subclass accessible\n- private: only in declaration of own class accessible\n\n\n## Mulitple inheritance\n\nMultiple parents. Can cause problems for the interpreter if same methods twice.\n\nSolved with Method Resolution Order (MRO): tries to find a linearization of all classes and depends on the order of inheritance. It doesn't find a feasible solution every time. Sometimes it helps to swap order. \n\n\n# Modules\n\npaths when import: \n\n- the current script sets the root for the ide but not for the terminal.\n- with `..` you can move up in the folder hierarchy. \n- instead of / or \\\\ python uses . \n- `from math import *` importes everything and you can refer to the function without `math.`\n  - not a good style since it can cause problems\n  \n## If name = main\n\nthe name of the script is only *main* if it's the root script.\n\nSo if you add: \n\n::: {#bc66689a .cell execution_count=24}\n``` {.python .cell-code}\nif __name__ = \"main\":\n  ...tests\n```\n:::\n\n\nyou can code functionality that only runs when the script is the root and doesn't run when the file has been imported into a different script. \n\n## Deep vs. Shallow Copy\n\nVariable stores references to an object that is stored in *one or more(string, lists, tuples..)* storage cells. So copying a variable, copies the reference:\n\n::: {#a35ee8c8 .cell execution_count=25}\n``` {.python .cell-code}\nx = 99.23\ny = x # copy of reference\n\nid(x) == id(y) \n\nx = 43.12\nid(x) == id(y)\n\n# But..\na = 19.2\nb = 19.2\n\nid(a) == id(b) #two different instances of object int\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\nFalse\n```\n:::\n:::\n\n\nAssigning a new value creates a new instance of object int by calling: `b = int.__new__(value)`.\n\nLists are mutable objects: x only refers to the first element of list. \n\n::: {#826a6429 .cell execution_count=26}\n``` {.python .cell-code}\nx = [1,2,3,4,5]\n\ny = x  #copy\ny[2] = 6 #change 3 element, doesnt' create a new object!!\n\nprint(x)\n\ny[0] = 9\nid(x) == id(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1, 2, 6, 4, 5]\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\nTrue\n```\n:::\n:::\n\n\nThis is a side effect. So we can create a real copy with the `copy()` function. Only available for mutable objects (sequences), so not for tuples.\n\n::: {#7cb8cac8 .cell execution_count=27}\n``` {.python .cell-code}\nx = [1,2,3,4,5]\n\ny = x.copy()\n\nid(x) == id(y)\n\nstr_text = 'hello'\n\n#str_copy = str_text.copy() doens't work since string gernally not mutable\n```\n:::\n\n\nNested Lists = special case. `copy()` *returns a shallow copy!*:\nNested lists are references to new storage location\n\n::: {#d6f2e7b7 .cell execution_count=28}\n``` {.python .cell-code}\nnested_list = [1,2,3,[4,5]]\n\ny = nested_list.copy()\n\ny[-1][0] = 99\n\nprint(y)\nprint(f'not desired change: {nested_list=}')\n\nprint(f'{id(y) == id(nested_list)=}')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1, 2, 3, [99, 5]]\nnot desired change: nested_list=[1, 2, 3, [99, 5]]\nid(y) == id(nested_list)=False\n```\n:::\n:::\n\n\n::: {#dd5ef7a7 .cell execution_count=29}\n``` {.python .cell-code}\n#import copy\nnested_list = [1,2,3,[4,5]]\n\n#y = nested_list.copy.deepcopy(nested_list)\ny[-1][0] = 99\n\nprint(f'didn\\'t change: {nested_list=}')\n```\n:::\n\n\n## Lambda Function\n\nKeep in mind:\n\n::: {#1a2adb8f .cell execution_count=30}\n``` {.python .cell-code}\ndef my_fun():\n  def inner_fun(x):\n    return x \n  return inner_fun\n\nmy_if = my_fun() #reference to inner function\nprint(my_if('hello'))\n\n#is the same as \n\nmy_if = my_fun #reference to outer function\nprint(my_if()('hello'))\n```\n:::\n\n\nLambda: No header. Only body of function. Only one expression.\n\n::: {#63335eb5 .cell execution_count=31}\n``` {.python .cell-code}\nx = lambda a,b: a + b\n\nprint('x: ', x(3,5))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nx:  8\n```\n:::\n:::\n\n\n::: {#dd52b2fc .cell execution_count=32}\n``` {.python .cell-code}\ndef fun():\n  return 'hello' \n  \nx = lambda: fun()\n\nprint('x: ', x())\n\nx = lambda a: a()\nprint('x: ', x(fun))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nx:  hello\nx:  hello\n```\n:::\n:::\n\n\nWe can use lambda for generic methods example: \n\n::: {#3bfdd108 .cell execution_count=33}\n``` {.python .cell-code}\ndef fun_ii(f, a, b):\n  return f(a,b)\n\nprint('fun_ii: ' , fun_ii(lambda x,y: x + y, 2, 3))\nprint('fun_ii: ' , fun_ii(lambda x,y: x - y, 2, 3))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfun_ii:  5\nfun_ii:  -1\n```\n:::\n:::\n\n\nUsually combined with other functions like `map()` or `sort()`.\n\n`map()`: applies a function to every single item of an iterable. Same as for loop.\n\n::: {#80ef353e .cell execution_count=34}\n``` {.python .cell-code}\nnumbers = [1,2,3,4]\ntest = map(lambda element: element-1,numbers) #we get a map object back\n\ntest = list(map(lambda element: element-1,numbers)) #create a list. List(test)\ntest\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```\n[0, 1, 2, 3]\n```\n:::\n:::\n\n\n`sort()`: sorts an iterable based on a given comparator\n\n::: {#de8a087c .cell execution_count=35}\n``` {.python .cell-code}\n#sorts based on remains after modulo\nnumbers = [1,2,3,4,6]\n\nnumbers.sort(key= lambda element: element %3)\nprint(numbers)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[3, 6, 1, 4, 2]\n```\n:::\n:::\n\n\n## List Comprehension\n\nSingle expression of for loop:\n\n::: {#ca74fdbf .cell execution_count=36}\n``` {.python .cell-code}\nx = [1,2,3,4,5,6]\nprint(x)\n\nx2 =[i**2 for i in x]\nprint(x2)\n\nx = [i**2 for i in x]\nprint(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1, 2, 3, 4, 5, 6]\n[1, 4, 9, 16, 25, 36]\n[1, 4, 9, 16, 25, 36]\n```\n:::\n:::\n\n\nAdd conditions\n\n::: {#0fac77ec .cell execution_count=37}\n``` {.python .cell-code}\nx = [1,2,3,4,5,6]\n\nx2 = [i**2 for i in x if i%2] #unequal numbers (>0 equals true)\nprint(x2)\n\nx3 = [i**2 for i in x if not i%2] #equal numbers !(>0 equals true)\nprint(x3)\n\nx4 = [i**2 if not i%2 else i-10 for i in x] #if else short-hand\nprint(x4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1, 9, 25]\n[4, 16, 36]\n[-9, 4, -7, 16, -5, 36]\n```\n:::\n:::\n\n\nNested Looops\n\n::: {#561f852b .cell execution_count=38}\n``` {.python .cell-code}\nli = [[1,2,3],[22,33]]\n\nres = [element*2 for row in li for element in row] #simple list return\nres2 = [[element*2 for element in row] for row in li] #nested list return\nprint(res)\nprint('\\n')\nprint(res2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[2, 4, 6, 44, 66]\n\n\n[[2, 4, 6], [44, 66]]\n```\n:::\n:::\n\n\nComprehension with tuples returns a generator but you can use unpacker `*`. \n\nDictionairy comprehension\n\n`zip()` returns list of tuples\n\n::: {#1da1c851 .cell execution_count=39}\n``` {.python .cell-code}\n#turn into dict\nx = [1,2,4,5]\n\nd = {i:i for i in x}\nprint(d)\nd1 = {k:v for (k,v) in enumerate(x)}\nprint(d1)\n\nd2 = {k:v for (k,v) in zip(['a','b','c'],x)}\nprint(d2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{1: 1, 2: 2, 4: 4, 5: 5}\n{0: 1, 1: 2, 2: 4, 3: 5}\n{'a': 1, 'b': 2, 'c': 4}\n```\n:::\n:::\n\n\n## Type Annotations\n\n",
    "supporting": [
      "basics_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}